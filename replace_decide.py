import pathlib

path = pathlib.Path('modules/brain/whole_brain.py')
text = path.read_text(encoding='utf-8')
start = text.find('    def decide(')
if start == -1:
    raise SystemExit('decide start not found')
end = text.find('@dataclass', start)
if end == -1:
    raise SystemExit('end marker not found')
new_block = (
"    def decide(\r\n"
"        self,\r\n"
"        perception: PerceptionSnapshot,\r\n"
"        emotion: EmotionSnapshot,\r\n"
"        personality: PersonalityProfile,\r\n"
"        curiosity: CuriosityState,\r\n"
"        learning_prediction: Optional[Dict[str, float]] = None,\r\n"
"        context: Optional[Dict[str, Any]] = None,\r\n"
"    ) -> Dict[str, Any]:\r\n"
"        context = context or {}\r\n"
"        summary = self._summarise_perception(perception)\r\n"
"        focus = max(summary, key=summary.get) if summary else None\r\n"
"        options = {\r\n"
"            \"observe\": 0.2 + (1 - abs(emotion.dimensions.get(\"valence\", 0.0))) * 0.3,\r\n"
"            \"approach\": 0.2 + emotion.intent_bias.get(\"approach\", 0.0),\r\n"
"            \"withdraw\": 0.2 + emotion.intent_bias.get(\"withdraw\", 0.0),\r\n"
"            \"explore\": 0.2 + emotion.intent_bias.get(\"explore\", 0.0) + curiosity.drive * 0.5,\r\n"
"        }\r\n"
"        if learning_prediction:\r\n"
"            predicted_load = float(learning_prediction.get(\"cpu\", 0.0))\r\n"
"            resource_pressure = float(learning_prediction.get(\"memory\", 0.0))\r\n"
"            options[\"observe\"] += max(0.0, predicted_load - 0.5) * 0.3\r\n"
"            options[\"withdraw\"] += max(0.0, resource_pressure - 0.5) * 0.2\r\n"
"            options[\"approach\"] += max(0.0, 0.5 - predicted_load) * 0.2\r\n"
"        if context.get(\"threat\", 0.0) > 0.4:\r\n"
"            options[\"withdraw\"] += 0.3\r\n"
"        if context.get(\"safety\", 0.0) > 0.5:\r\n"
"            options[\"approach\"] += 0.2\r\n"
"        options[\"explore\"] *= 0.5 + personality.modulation_weight(\"explore\")\r\n"
"        options[\"approach\"] *= 0.5 + personality.modulation_weight(\"social\")\r\n"
"        options[\"withdraw\"] *= 0.5 + personality.modulation_weight(\"caution\")\r\n"
"        options[\"observe\"] *= 0.5 + personality.modulation_weight(\"persist\")\r\n"
"        total = sum(options.values()) or 1.0\r\n"
"        weights = {k: v / total for k, v in options.items()}\r\n"
"        intention = max(weights.items(), key=lambda item: item[1])[0]\r\n"
"        confidence = weights[intention]\r\n"
"        plan = self._build_plan(intention, summary, context, focus)\r\n"
"        tags = [intention]\r\n"
"        if confidence >= 0.65:\r\n"
"            tags.append(\"high-confidence\")\r\n"
"        if curiosity.last_novelty > 0.6:\r\n"
"            tags.append(\"novelty-driven\")\r\n"
"        if focus:\r\n"
"            tags.append(f\"focus-{focus}\")\r\n"
"        self._remember(summary, emotion, intention, confidence)\r\n"
"        thought_trace = [\r\n"
"            f\"focus={focus or 'none'}\",\r\n"
"            f\"intention={intention}\",\r\n"
"            f\"emotion={emotion.primary.value}:{emotion.intensity:.2f}\",\r\n"
"            f\"curiosity={curiosity.drive:.2f}\",\r\n"
"        ]\r\n"
"        if learning_prediction:\r\n"
"            thought_trace.append(\r\n"
"                f\"predicted_cpu={float(learning_prediction.get('cpu', 0.0)):.2f}\"\r\n"
"            )\r\n"
"            thought_trace.append(\r\n"
"                f\"predicted_mem={float(learning_prediction.get('memory', 0.0)):.2f}\"\r\n"
"            )\r\n"
"        summary_text = ', '.join(f\"{k}:{v:.2f}\" for k, v in summary.items()) or 'no-salient-modalities'\r\n"
"        decision = {\r\n"
"            \"intention\": intention,\r\n"
"            \"plan\": plan,\r\n"
"            \"confidence\": confidence,\r\n"
"            \"weights\": weights,\r\n"
"            \"tags\": tags,\r\n"
"            \"focus\": focus or intention,\r\n"
"            \"summary\": summary_text,\r\n"
"            \"thought_trace\": thought_trace,\r\n"
"            \"perception_summary\": summary,\r\n"
"        }\r\n"
"        return decision\r\n\r\n"
)
text = text[:start] + new_block + text[end:]
path.write_text(text, encoding='utf-8')
