#!/usr/bin/env python3
"""Generate documentation for UserConfigurable fields.

This script walks the AutoGPT codebase to find classes that use the
``UserConfigurable`` field helper. It extracts the field name, default
value and the field's description (taken from the triple-quoted string
immediately following the field definition) and writes them to a
Markdown document.

The output file can be specified with ``--output`` and defaults to
``docs/configuration.md``. Multiple output paths may be provided to
write the same content to several locations.
"""
from __future__ import annotations

import ast
from pathlib import Path
from typing import Iterable, Optional, Tuple, Sequence
import argparse

REPO_ROOT = Path(__file__).resolve().parents[1]
BACKEND_ROOT = REPO_ROOT / "backend" / "autogpt" / "autogpt"


def iter_user_configurable_fields(
    tree: ast.AST, source: str
) -> Iterable[Tuple[str, list[Tuple[str, Optional[str], str]]]]:
    """Yield classes and their UserConfigurable fields.

    Returns tuples of (class_name, fields) where fields is a list of
    (field_name, default_value, description).
    """
    for node in tree.body:
        if not isinstance(node, ast.ClassDef):
            continue
        fields = []
        for idx, stmt in enumerate(node.body):
            if isinstance(stmt, ast.AnnAssign) and isinstance(stmt.value, ast.Call):
                call = stmt.value
                func = call.func
                func_name = None
                if isinstance(func, ast.Name):
                    func_name = func.id
                elif isinstance(func, ast.Attribute):
                    func_name = func.attr
                if func_name != "UserConfigurable":
                    continue
                if isinstance(stmt.target, ast.Name):
                    field_name = stmt.target.id
                else:
                    continue
                default: Optional[str] = None
                if call.args:
                    default = ast.get_source_segment(source, call.args[0])
                else:
                    for kw in call.keywords:
                        if kw.arg == "default":
                            default = ast.get_source_segment(source, kw.value)
                            break
                description = ""
                if idx + 1 < len(node.body):
                    next_stmt = node.body[idx + 1]
                    if (
                        isinstance(next_stmt, ast.Expr)
                        and isinstance(next_stmt.value, ast.Constant)
                        and isinstance(next_stmt.value.value, str)
                    ):
                        description = next_stmt.value.value.strip().replace("\n", " ")
                fields.append((field_name, default, description))
        if fields:
            yield node.name, fields


def generate_markdown(entries: Iterable[Tuple[str, list[Tuple[str, Optional[str], str]]]], module: str) -> str:
    lines = []
    for class_name, fields in entries:
        lines.append(f"## `{module}.{class_name}`")
        lines.append("")
        lines.append("| Field | Default | Description |")
        lines.append("| --- | --- | --- |")
        for name, default, desc in fields:
            default_str = (default or "").replace("\n", " ").replace("|", "\\|")
            if len(default_str) > 60:
                default_str = default_str[:57] + "..."
            desc_str = desc.replace("|", "\\|")
            lines.append(f"| `{name}` | `{default_str}` | {desc_str} |")
        lines.append("")
    return "\n".join(lines)


def main(args: Sequence[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--output",
        "-o",
        nargs="+",
        default=[REPO_ROOT / "docs" / "configuration.md"],
        help="One or more output files to write the documentation to.",
    )
    parsed = parser.parse_args(args)
    output_paths = [Path(p) for p in parsed.output]

    sections = [
        "<!-- Auto-generated by scripts/generate_user_config_docs.py -->",
        "# User Configurable Fields",
        "",
    ]
    for path in sorted(BACKEND_ROOT.rglob("*.py")):
        source = path.read_text(encoding="utf-8")
        try:
            tree = ast.parse(source, filename=str(path))
        except SyntaxError:
            # Skip files that contain syntax errors (e.g. merge conflict markers)
            continue
        entries = list(iter_user_configurable_fields(tree, source))
        if not entries:
            continue
        module = (
            path.relative_to(BACKEND_ROOT).with_suffix("").as_posix().replace("/", ".")
        )
        sections.append(generate_markdown(entries, module))

    doc_text = "\n".join(sections)
    for out_path in output_paths:
        out_path = out_path if out_path.is_absolute() else REPO_ROOT / out_path
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(doc_text, encoding="utf-8")
        print(f"Wrote documentation to {out_path}")


if __name__ == "__main__":
    main()

