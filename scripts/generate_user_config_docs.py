#!/usr/bin/env python3
"""Generate documentation for UserConfigurable fields.

This script walks the AutoGPT codebase to find classes that use the
``UserConfigurable`` field helper. It extracts the field name, default
value and the field's description (taken from the triple-quoted string
immediately following the field definition) and writes them to a
Markdown document.

The resulting file is written to
``docs/AutoGPT/configuration/user_configurable.md``.
"""
from __future__ import annotations

import ast
from pathlib import Path
from typing import Iterable, Optional, Tuple

REPO_ROOT = Path(__file__).resolve().parents[1]
BACKEND_ROOT = REPO_ROOT / "backend" / "autogpt" / "autogpt"
OUTPUT_PATH = REPO_ROOT / "docs" / "AutoGPT" / "configuration" / "user_configurable.md"


def iter_user_configurable_fields(
    tree: ast.AST, source: str
) -> Iterable[Tuple[str, list[Tuple[str, Optional[str], str]]]]:
    """Yield classes and their UserConfigurable fields.

    Returns tuples of (class_name, fields) where fields is a list of
    (field_name, default_value, description).
    """
    for node in tree.body:
        if not isinstance(node, ast.ClassDef):
            continue
        fields = []
        for idx, stmt in enumerate(node.body):
            if isinstance(stmt, ast.AnnAssign) and isinstance(stmt.value, ast.Call):
                call = stmt.value
                func = call.func
                func_name = None
                if isinstance(func, ast.Name):
                    func_name = func.id
                elif isinstance(func, ast.Attribute):
                    func_name = func.attr
                if func_name != "UserConfigurable":
                    continue
                if isinstance(stmt.target, ast.Name):
                    field_name = stmt.target.id
                else:
                    continue
                default: Optional[str] = None
                if call.args:
                    default = ast.get_source_segment(source, call.args[0])
                else:
                    for kw in call.keywords:
                        if kw.arg == "default":
                            default = ast.get_source_segment(source, kw.value)
                            break
                description = ""
                if idx + 1 < len(node.body):
                    next_stmt = node.body[idx + 1]
                    if (
                        isinstance(next_stmt, ast.Expr)
                        and isinstance(next_stmt.value, ast.Constant)
                        and isinstance(next_stmt.value.value, str)
                    ):
                        description = next_stmt.value.value.strip().replace("\n", " ")
                fields.append((field_name, default, description))
        if fields:
            yield node.name, fields


def generate_markdown(entries: Iterable[Tuple[str, list[Tuple[str, Optional[str], str]]]], module: str) -> str:
    lines = []
    for class_name, fields in entries:
        lines.append(f"## `{module}.{class_name}`")
        lines.append("")
        lines.append("| Field | Default | Description |")
        lines.append("| --- | --- | --- |")
        for name, default, desc in fields:
            default_str = (default or "").replace("\n", " ").replace("|", "\\|")
            if len(default_str) > 60:
                default_str = default_str[:57] + "..."
            desc_str = desc.replace("|", "\\|")
            lines.append(f"| `{name}` | `{default_str}` | {desc_str} |")
        lines.append("")
    return "\n".join(lines)


def main() -> None:
    sections = ["<!-- Auto-generated by scripts/generate_user_config_docs.py -->", "# User Configurable Fields", ""]
    for path in sorted(BACKEND_ROOT.rglob("*.py")):
        source = path.read_text(encoding="utf-8")
        try:
            tree = ast.parse(source, filename=str(path))
        except SyntaxError:
            # Skip files that contain syntax errors (e.g. merge conflict markers)
            continue
        entries = list(iter_user_configurable_fields(tree, source))
        if not entries:
            continue
        module = path.relative_to(BACKEND_ROOT).with_suffix("").as_posix().replace("/", ".")
        sections.append(generate_markdown(entries, module))
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text("\n".join(sections), encoding="utf-8")
    print(f"Wrote documentation to {OUTPUT_PATH}")


if __name__ == "__main__":
    main()

